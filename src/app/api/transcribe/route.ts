import { NextResponse } from 'next/server'
import { table, minifyData } from "../../utils/airtable"
import { OpenAIClient, AzureKeyCredential } from '@azure/openai';
import axios from 'axios';
import fs from 'fs';
import path from 'path';

export async function GET() {
    try {
        const records = await table.select({}).all();
        const minifiedRecords = await minifyData(records);

        return new NextResponse(JSON.stringify(minifiedRecords), {
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          },
        })
   
    } catch (error) {
        console.error('Error handling GET request for data:', error);
        return NextResponse.json({ "message": "Error handling GET request for data" })
    }
}

/**
 * 
 * @param req 
 * @returns updated jp_text generated by Azure ChatGPT 4
 */
export async function PUT(req: Request) {
      try {
        const {id} = await req.json()
        const singleRecord = await table.find(id)
        const jp_text = singleRecord.get('jp_text')

        const prompt = `文章を読み取り、会話の前後がおかしかったり、体裁がおかしな部分があれば修正した文章を生成してください。生成フォーマットはそのまま使用してください。`
        const messages = [
            {
              role: 'user',
              content: jp_text,
            },
            { role: 'assistant', content: prompt },
        ];

        const client = new OpenAIClient(
          process.env.AZURE_ENDPOINT ,
          new AzureKeyCredential(process.env.AZURE_API_KEY ),
        );
        const deploymentId = 'gpt-4-test';
        const options = {
            temperature: 1,
        };
        const result = await client.getChatCompletions(
            deploymentId,
            messages,
            options,
        );

        for (const choice of result.choices) {
          const newData = `${choice.message?.content}`;
          const updatedField = {
            'jp_fix_text': newData
          }
          const updatedRecords = await table.update(id, updatedField);

          return new NextResponse(JSON.stringify(updatedRecords), {
            status: 200,
            headers: {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
              'Access-Control-Allow-Headers': 'Content-Type, Authorization',
            },
          })
        } 

      } catch (error) {
        console.error('Error handling first POST request:', error);
        return NextResponse.json({ "message": "Missing required data" })
      }
}

export async function POST(req: Request) {

  try {
   // download first the video link 
   const { id } = await req.json()
   const singleRecord = await table.find(id)
   const video_url = singleRecord.get('video_url')

// Replace with your Airtable API endpoint URL
const airtableAttachmentUrl = 'https://api.airtable.com/v0/appHpS1houbYiAcWa/Projects/' + encodeURIComponent('atthNcH2IquEBCeRo');

// Replace with your Airtable API key
const apiKey = 'patDKJRRKA7EnF21m.771fcf78fa8736028f1aee0849c7ca7a0ef1e5dbc744b6b9352d1dabc6b108e6';

const headers = {
  Authorization: `Bearer ${apiKey}`,
};

// Make a GET request to the Airtable attachment URL
await axios
  .get(airtableAttachmentUrl, { headers, responseType: 'stream' })
  .then((response) => {
    // Specify the path where you want to save the downloaded file
    const filePath = 'public/downloads/file.ext';

    // Create a write stream to save the attachment
    const writer = fs.createWriteStream(filePath);

    // Pipe the attachment data to the write stream
    response.data.pipe(writer);

    // Handle the completion of the write stream
    writer.on('finish', () => {
      console.log('Attachment downloaded successfully.');
    });

    // Handle errors
    writer.on('error', (err) => {
      console.error('Error saving attachment:', err);
    });
  })
  .catch((error) => {
    console.error('Error downloading attachment:', error);
  });



   // const response = await axios.get('https://www.youtube.com/watch?v=wbYGdCslFVg&t=2s&ab_channel=ZoumDataScience', { responseType: 'stream' });
  //  const filePath = path.join(process.cwd(), 'public', 'tmp.mp3');
  //  const writer = fs.createWriteStream(filePath);
    
  //  response.data.pipe(writer);

  //  writer.on('finish', () => {
  //     // return NextResponse.json({ "message": "Video downloaded and saved successfully" })
  //     return new NextResponse( "Video downloaded and saved successfully", {
  //       status: 200,
  //       headers: {
  //         'Access-Control-Allow-Origin': '*',
  //         'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  //         'Access-Control-Allow-Headers': 'Content-Type, Authorization',
  //       },
  //     })
  //   });

  //   // Handle errors
  //   writer.on('error', (err) => {
  //     console.error('Error saving video:', err);
  //     return NextResponse.json({ "message": "An error occurred while saving the video." })
      
  //   });


  } catch (error) {
    console.error('Error downloading video:', error);
    return NextResponse.json({ "message": "An error occurred while downloading the video."})
  }

}
  


